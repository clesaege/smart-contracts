import test from "ava";
import api from "../../utils/lib/api";
import { deployContract, retrieveContract } from "../../utils/lib/contracts";
import getAllBalances from "../../utils/lib/getAllBalances";
import deployEnvironment from "../../utils/deploy/contracts";
import { getTermsSignatureParameters } from "../../utils/lib/signing";
import governanceAction from "../../utils/lib/governanceAction";
import { updateCanonicalPriceFeed } from "../../utils/lib/updatePriceFeed";

const BigNumber = require("bignumber.js");
const environmentConfig = require("../../utils/config/environment.js");

const environment = "development";
const config = environmentConfig[environment];

BigNumber.config({ ERRORS: false });

// hoisted variables
let accounts;
let deployer;
let ethToken;
let fund;
let gasPrice;
let investor;
let manager;
let mlnToken;
let pricefeed;
let txId;
let runningGasTotal;
let exchanges;
let trade1;
let trade2;
let trade3;
let trade4;
let version;
let deployed;

// mock data
const offeredValue = new BigNumber(10 ** 22);
const wantedShares = new BigNumber(10 ** 22);
const numberofExchanges = 2;

// define order signatures
const makeOrderSignature = api.util
  .abiSignature("makeOrder", [
    "address",
    "address[5]",
    "uint256[8]",
    "bytes32",
    "uint8",
    "bytes32",
    "bytes32",
  ])
  .slice(0, 10);
const takeOrderSignature = api.util
  .abiSignature("takeOrder", [
    "address",
    "address[5]",
    "uint256[8]",
    "bytes32",
    "uint8",
    "bytes32",
    "bytes32",
  ])
  .slice(0, 10);
const cancelOrderSignature = api.util
  .abiSignature("cancelOrder", [
    "address",
    "address[5]",
    "uint256[8]",
    "bytes32",
    "uint8",
    "bytes32",
    "bytes32",
  ])
  .slice(0, 10);

test.before(async () => {
  deployed = await deployEnvironment(environment);
  accounts = await api.eth.accounts();
  gasPrice = Number(await api.eth.gasPrice());
  [deployer, manager, investor] = accounts;
  version = await deployed.Version;
  pricefeed = await deployed.CanonicalPriceFeed;
  mlnToken = await deployed.MlnToken;
  ethToken = await deployed.EthToken;
  // TODO: do we really need to deploy the matchingmarket here again?
  deployed.MatchingMarket = await deployContract(
    "exchange/thirdparty/MatchingMarket",
    { from: deployer, gas: config.gas },
    [1546304461],
  );
  deployed.MatchingMarketAdapter = await deployContract(
    "exchange/adapter/MatchingMarketAdapter",
    { from: deployer },
    [deployed.MatchingMarket.address],
  );
  exchanges = [deployed.SimpleMarket, deployed.MatchingMarket];
  await governanceAction(
    { from: deployer },
    deployed.Governance,
    deployed.CanonicalPriceFeed,
    "registerExchange",
    [
      deployed.SimpleMarket.address,
      deployed.MatchingMarketAdapter.address,
      true,
      [makeOrderSignature, takeOrderSignature, cancelOrderSignature],
    ],
  );
  await governanceAction(
    { from: deployer },
    deployed.Governance,
    deployed.CanonicalPriceFeed,
    "registerExchange",
    [
      deployed.MatchingMarket.address,
      deployed.MatchingMarketAdapter.address,
      true,
      [makeOrderSignature, takeOrderSignature, cancelOrderSignature],
    ],
  );

  const [r, s, v] = await getTermsSignatureParameters(manager);
  await version.instance.setupFund.postTransaction(
    { from: manager, gas: config.gas, gasPrice: config.gasPrice },
    [
      "Test fund", // name
      deployed.EthToken.address, // reference asset
      config.protocol.fund.managementFee,
      config.protocol.fund.performanceFee,
      deployed.NoCompliance.address,
      deployed.RMMakeOrders.address,
      [deployed.SimpleMarket.address, deployed.MatchingMarket.address],
      [],
      v,
      r,
      s,
    ],
  );
  const fundAddress = await version.instance.managerToFunds.call({}, [manager]);
  fund = await retrieveContract("Fund", fundAddress);
  await deployed.MatchingMarket.instance.addTokenPairWhitelist.postTransaction(
    { from: deployer, gasPrice: config.gasPrice },
    [mlnToken.address, ethToken.address],
  );
  // Change competition address to investor just for testing purpose so it allows invest / redeem
  await deployed.CompetitionCompliance.instance.changeCompetitionAddress.postTransaction(
    { from: deployer, gas: config.gas, gasPrice: config.gasPrice },
    [investor],
  );
});

test.beforeEach(async () => {
  runningGasTotal = new BigNumber(0);
  await updateCanonicalPriceFeed(deployed);

  const [
    ,
    referencePrice,
  ] = await pricefeed.instance.getReferencePriceInfo.call({}, [
    ethToken.address,
    mlnToken.address,
  ]);
  const [
    ,
    invertedReferencePrice,
  ] = await pricefeed.instance.getReferencePriceInfo.call({}, [
    mlnToken.address,
    ethToken.address,
  ]);
  const sellQuantity1 = new BigNumber(10 ** 21);
  trade1 = {
    sellQuantity: sellQuantity1,
    buyQuantity: new BigNumber(
      Math.round(referencePrice.div(10 ** 18).times(sellQuantity1)),
    ),
  };
  const sellQuantity2 = new BigNumber(50 * 10 ** 18);
  trade2 = {
    sellQuantity: sellQuantity2,
    buyQuantity: new BigNumber(
      Math.round(referencePrice / 10 ** 18 * sellQuantity2),
    ),
  };
  const sellQuantity3 = new BigNumber(5 * 10 ** 18);
  trade3 = {
    sellQuantity: sellQuantity3,
    buyQuantity: new BigNumber(
      Math.round(invertedReferencePrice / 10 ** 18 * sellQuantity3 / 10),
    ),
  };
  const sellQuantity4 = new BigNumber(5 * 10 ** 18);
  trade4 = {
    sellQuantity: sellQuantity4,
    buyQuantity: new BigNumber(
      Math.round(invertedReferencePrice / 10 ** 18 * sellQuantity4 * 1000),
    ),
  };
});

const initialTokenAmount = new BigNumber(10 ** 23);
test.serial("investor receives initial ethToken for testing", async t => {
  const pre = await getAllBalances(deployed, accounts, fund);
  const preDeployerEth = new BigNumber(await api.eth.getBalance(deployer));
  txId = await ethToken.instance.transfer.postTransaction(
    { from: deployer, gasPrice: config.gasPrice },
    [investor, initialTokenAmount, ""],
  );
  const gasUsed = (await api.eth.getTransactionReceipt(txId)).gasUsed;
  runningGasTotal = runningGasTotal.plus(gasUsed);
  const postDeployerEth = new BigNumber(await api.eth.getBalance(deployer));
  const post = await getAllBalances(deployed, accounts, fund);

  t.deepEqual(
    postDeployerEth,
    preDeployerEth.minus(runningGasTotal.times(gasPrice)),
  );
  t.deepEqual(
    post.investor.EthToken,
    pre.investor.EthToken.add(initialTokenAmount),
  );
  t.deepEqual(post.investor.MlnToken, pre.investor.MlnToken);
  t.deepEqual(post.investor.ether, pre.investor.ether);
  t.deepEqual(post.manager.EthToken, pre.manager.EthToken);
  t.deepEqual(post.manager.MlnToken, pre.manager.MlnToken);
  t.deepEqual(post.investor.ether, pre.investor.ether);
  t.deepEqual(post.fund.MlnToken, pre.fund.MlnToken);
  t.deepEqual(post.fund.EthToken, pre.fund.EthToken);
  t.deepEqual(post.fund.ether, pre.fund.ether);
});

const exchangeIndexes = Array.from(
  new Array(numberofExchanges),
  (val, index) => index,
);
exchangeIndexes.forEach(i => {
  test.serial(
    `fund gets ETH Token from investment [round ${i + 1}]`,
    async t => {
      const boostedOffer = offeredValue.times(1.01); // account for increasing share price after trades occur
      let investorGasTotal = new BigNumber(0);
      await ethToken.instance.transfer.postTransaction(
        { from: deployer, gasPrice: config.gasPrice },
        [investor, new BigNumber(10 ** 14), ""],
      );
      const pre = await getAllBalances(deployed, accounts, fund);
      txId = await ethToken.instance.approve.postTransaction(
        { from: investor, gas: config.gas },
        [fund.address, boostedOffer],
      );
      let gasUsed = (await api.eth.getTransactionReceipt(txId)).gasUsed;
      investorGasTotal = investorGasTotal.plus(gasUsed);
      txId = await fund.instance.requestInvestment.postTransaction(
        { from: investor, gas: config.gas },
        [boostedOffer, wantedShares, ethToken.address],
      );
      gasUsed = (await api.eth.getTransactionReceipt(txId)).gasUsed;
      investorGasTotal = investorGasTotal.plus(gasUsed);
      await updateCanonicalPriceFeed(deployed);
      await updateCanonicalPriceFeed(deployed);
      const totalSupply = await fund.instance.totalSupply.call();
      const requestId = await fund.instance.getLastRequestId.call();
      txId = await fund.instance.executeRequest.postTransaction(
        { from: investor, gas: config.gas },
        [requestId],
      );
      gasUsed = (await api.eth.getTransactionReceipt(txId)).gasUsed;
      investorGasTotal = investorGasTotal.plus(gasUsed);
      // set approved token back to zero
      txId = await ethToken.instance.approve.postTransaction(
        { from: investor },
        [fund.address, 0],
      );
      investorGasTotal = investorGasTotal.plus(
        (await api.eth.getTransactionReceipt(txId)).gasUsed,
      );
      const post = await getAllBalances(deployed, accounts, fund);
      const [gav, , , unclaimedFees, ,] = Object.values(
        await fund.instance.atLastUnclaimedFeeAllocation.call(),
      );
      const feesShareQuantity = parseInt(
        unclaimedFees
          .mul(totalSupply)
          .div(gav)
          .toNumber(),
        0,
      );
      let sharePrice = await fund.instance.calcValuePerShare.call({}, [
        gav,
        totalSupply.add(feesShareQuantity),
      ]);
      if (sharePrice.toNumber() === 0) {
        sharePrice = new BigNumber(10 ** 18);
      }
      const estimatedEthSpent = wantedShares
        .times(sharePrice)
        .dividedBy(new BigNumber(10 ** 18));

      t.deepEqual(post.worker.EthToken, pre.worker.EthToken);
      t.deepEqual(post.investor.MlnToken, pre.investor.MlnToken);
      t.deepEqual(
        post.investor.EthToken,
        pre.investor.EthToken.minus(estimatedEthSpent),
      );
      t.deepEqual(
        post.investor.ether,
        pre.investor.ether.minus(investorGasTotal.times(gasPrice)),
      );
      t.deepEqual(post.manager.EthToken, pre.manager.EthToken);
      t.deepEqual(post.manager.MlnToken, pre.manager.MlnToken);
      t.deepEqual(post.manager.ether, pre.manager.ether);
      t.deepEqual(post.fund.EthToken, pre.fund.EthToken.add(estimatedEthSpent));
      t.deepEqual(post.fund.MlnToken, pre.fund.MlnToken);
      t.deepEqual(post.fund.ether, pre.fund.ether);
    },
  );

  test.serial(
    `Exchange ${i +
      1}: manager makes order, and sellToken (ETH-T) is transferred to exchange`,
    async t => {
      const pre = await getAllBalances(deployed, accounts, fund);
      const exchangePreMln = await mlnToken.instance.balanceOf.call({}, [
        exchanges[i].address,
      ]);
      const exchangePreEthToken = await ethToken.instance.balanceOf.call({}, [
        exchanges[i].address,
      ]);
      await updateCanonicalPriceFeed(deployed);
      txId = await fund.instance.callOnExchange.postTransaction(
        { from: manager, gas: config.gas },
        [
          i,
          makeOrderSignature,
          ["0x0", "0x0", ethToken.address, mlnToken.address, "0x0"],
          [trade1.sellQuantity, trade1.buyQuantity, 0, 0, 0, 0, 0, 0],
          "0x0",
          0,
          "0x0",
          "0x0",
        ],
      );
      const gasUsed = (await api.eth.getTransactionReceipt(txId)).gasUsed;
      runningGasTotal = runningGasTotal.plus(gasUsed);
      const exchangePostMln = await mlnToken.instance.balanceOf.call({}, [
        exchanges[i].address,
      ]);
      const exchangePostEthToken = await ethToken.instance.balanceOf.call({}, [
        exchanges[i].address,
      ]);
      const post = await getAllBalances(deployed, accounts, fund);

      t.deepEqual(exchangePostMln, exchangePreMln);
      t.deepEqual(
        exchangePostEthToken,
        exchangePreEthToken.add(trade1.sellQuantity),
      );
      t.deepEqual(post.investor.MlnToken, pre.investor.MlnToken);
      t.deepEqual(post.investor.EthToken, pre.investor.EthToken);
      t.deepEqual(post.investor.ether, pre.investor.ether);
      t.deepEqual(post.manager.EthToken, pre.manager.EthToken);
      t.deepEqual(post.manager.MlnToken, pre.manager.MlnToken);
      t.deepEqual(
        post.manager.ether,
        pre.manager.ether.minus(runningGasTotal.times(gasPrice)),
      );
      t.deepEqual(post.fund.MlnToken, pre.fund.MlnToken);
      t.deepEqual(
        post.fund.EthToken,
        pre.fund.EthToken.minus(trade1.sellQuantity),
      );
      t.deepEqual(post.fund.ether, pre.fund.ether);
    },
  );

  test.serial(
    `Exchange ${i +
      1}: third party takes entire order, allowing fund to receive mlnToken`,
    async t => {
      const pre = await getAllBalances(deployed, accounts, fund);
      const orderId = await exchanges[i].instance.last_offer_id.call({}, []);
      const exchangePreMln = Number(
        await mlnToken.instance.balanceOf.call({}, [exchanges[i].address]),
      );
      const exchangePreEthToken = Number(
        await ethToken.instance.balanceOf.call({}, [exchanges[i].address]),
      );
      txId = await mlnToken.instance.approve.postTransaction(
        { from: deployer, gasPrice: config.gasPrice },
        [exchanges[i].address, trade1.buyQuantity.add(100)],
      );
      let gasUsed = (await api.eth.getTransactionReceipt(txId)).gasUsed;
      runningGasTotal = runningGasTotal.plus(gasUsed);
      txId = await exchanges[i].instance.buy.postTransaction(
        { from: deployer, gas: config.gas, gasPrice: config.gasPrice },
        [orderId, trade1.sellQuantity],
      );
      gasUsed = (await api.eth.getTransactionReceipt(txId)).gasUsed;
      runningGasTotal = runningGasTotal.plus(gasUsed);
      const exchangePostMln = Number(
        await mlnToken.instance.balanceOf.call({}, [exchanges[i].address]),
      );
      const exchangePostEthToken = Number(
        await ethToken.instance.balanceOf.call({}, [exchanges[i].address]),
      );
      const post = await getAllBalances(deployed, accounts, fund);

      t.deepEqual(exchangePostMln, exchangePreMln);
      console.log(exchangePostEthToken);
      t.deepEqual(
        exchangePostEthToken,
        exchangePreEthToken - trade1.sellQuantity,
      );
      t.deepEqual(
        post.deployer.ether,
        pre.deployer.ether.minus(runningGasTotal.times(gasPrice)),
      );
      t.deepEqual(
        post.deployer.MlnToken,
        pre.deployer.MlnToken.minus(trade1.buyQuantity),
      );
      t.deepEqual(
        post.deployer.EthToken,
        pre.deployer.EthToken.add(trade1.sellQuantity),
      );
      t.deepEqual(post.investor.MlnToken, pre.investor.MlnToken);
      t.deepEqual(post.investor.EthToken, pre.investor.EthToken);
      t.deepEqual(post.investor.ether, pre.investor.ether);
      t.deepEqual(post.manager.EthToken, pre.manager.EthToken);
      t.deepEqual(post.manager.MlnToken, pre.manager.MlnToken);
      t.deepEqual(post.manager.ether, pre.manager.ether);
      t.deepEqual(
        post.fund.MlnToken,
        pre.fund.MlnToken.add(trade1.buyQuantity),
      );
      t.deepEqual(post.fund.EthToken, pre.fund.EthToken);
      t.deepEqual(post.fund.ether, pre.fund.ether);
    },
  );

  test.serial(
    `Exchange ${i +
      1}: third party makes order (sell ETH-T for MLN-T), and ETH-T is transferred to exchange`,
    async t => {
      const pre = await getAllBalances(deployed, accounts, fund);
      const exchangePreMln = await mlnToken.instance.balanceOf.call({}, [
        exchanges[i].address,
      ]);
      const exchangePreEthToken = await ethToken.instance.balanceOf.call({}, [
        exchanges[i].address,
      ]);
      txId = await ethToken.instance.approve.postTransaction(
        { from: deployer, gasPrice: config.gasPrice },
        [exchanges[i].address, trade2.sellQuantity],
      );
      let gasUsed = (await api.eth.getTransactionReceipt(txId)).gasUsed;
      runningGasTotal = runningGasTotal.plus(gasUsed);
      txId = await exchanges[i].instance.offer.postTransaction(
        { from: deployer, gas: config.gas, gasPrice: config.gasPrice },
        [
          trade2.sellQuantity,
          ethToken.address,
          trade2.buyQuantity,
          mlnToken.address,
        ],
      );
      gasUsed = (await api.eth.getTransactionReceipt(txId)).gasUsed;
      runningGasTotal = runningGasTotal.plus(gasUsed);
      const exchangePostMln = await mlnToken.instance.balanceOf.call({}, [
        exchanges[i].address,
      ]);
      const exchangePostEthToken = await ethToken.instance.balanceOf.call({}, [
        exchanges[i].address,
      ]);
      const post = await getAllBalances(deployed, accounts, fund);

      t.deepEqual(exchangePostMln, exchangePreMln);
      t.deepEqual(
        exchangePostEthToken,
        exchangePreEthToken.add(trade2.sellQuantity),
      );
      t.deepEqual(
        post.deployer.EthToken,
        pre.deployer.EthToken.minus(trade2.sellQuantity),
      );
      t.deepEqual(post.deployer.MlnToken, pre.deployer.MlnToken);
      t.deepEqual(
        post.deployer.ether,
        pre.deployer.ether.minus(runningGasTotal.times(gasPrice)),
      );
      t.deepEqual(post.investor.MlnToken, pre.investor.MlnToken);
      t.deepEqual(post.investor.EthToken, pre.investor.EthToken);
      t.deepEqual(post.investor.ether, pre.investor.ether);
      t.deepEqual(post.manager.EthToken, pre.manager.EthToken);
      t.deepEqual(post.manager.MlnToken, pre.manager.MlnToken);
      t.deepEqual(post.manager.ether, pre.manager.ether);
      t.deepEqual(post.fund.MlnToken, pre.fund.MlnToken);
      t.deepEqual(post.fund.EthToken, pre.fund.EthToken);
      t.deepEqual(post.fund.ether, pre.fund.ether);
    },
  );

  test.serial(
    `Exchange ${i + 1}: manager takes order (buys ETH-T for MLN-T)`,
    async t => {
      const pre = await getAllBalances(deployed, accounts, fund);
      const exchangePreMln = Number(
        await mlnToken.instance.balanceOf.call({}, [exchanges[i].address]),
      );
      const exchangePreEthToken = Number(
        await ethToken.instance.balanceOf.call({}, [exchanges[i].address]),
      );
      const orderId = await exchanges[i].instance.last_offer_id.call({}, []);
      txId = await fund.instance.callOnExchange.postTransaction(
        { from: manager, gas: config.gas },
        [
          i,
          takeOrderSignature,
          ["0x0", "0x0", "0x0", "0x0", "0x0"],
          [0, 0, 0, 0, 0, 0, trade2.buyQuantity, 0],
          `0x${Number(orderId).toString(16).padStart(64, "0")}`,
          0,
          "0x0",
          "0x0",
        ],
      );
      const gasUsed = (await api.eth.getTransactionReceipt(txId)).gasUsed;
      runningGasTotal = runningGasTotal.plus(gasUsed);
      const exchangePostMln = Number(
        await mlnToken.instance.balanceOf.call({}, [exchanges[i].address]),
      );
      const exchangePostEthToken = Number(
        await ethToken.instance.balanceOf.call({}, [exchanges[i].address]),
      );
      const post = await getAllBalances(deployed, accounts, fund);

      t.deepEqual(exchangePostMln, exchangePreMln);
      t.deepEqual(
        exchangePostEthToken,
        exchangePreEthToken - trade2.sellQuantity,
      );
      t.deepEqual(
        post.deployer.MlnToken,
        pre.deployer.MlnToken.add(trade2.buyQuantity),
      );
      t.deepEqual(post.deployer.EthToken, pre.deployer.EthToken);
      t.deepEqual(post.deployer.ether, pre.deployer.ether);
      t.deepEqual(post.investor.MlnToken, pre.investor.MlnToken);
      t.deepEqual(post.investor.EthToken, pre.investor.EthToken);
      t.deepEqual(post.investor.ether, pre.investor.ether);
      t.deepEqual(post.manager.EthToken, pre.manager.EthToken);
      t.deepEqual(post.manager.MlnToken, pre.manager.MlnToken);
      t.deepEqual(
        post.manager.ether,
        pre.manager.ether.minus(runningGasTotal.times(gasPrice)),
      );
      t.deepEqual(
        post.fund.MlnToken,
        pre.fund.MlnToken.minus(trade2.buyQuantity),
      );
      t.deepEqual(
        post.fund.EthToken,
        pre.fund.EthToken.add(trade2.sellQuantity),
      );
      t.deepEqual(post.fund.ether, pre.fund.ether);
    },
  );
});

test.serial(
  "manager tries to make a bad order (sell MLN-T for ETH-T), RMMakeOrders should prevent this",
  async t => {
    const pre = await getAllBalances(deployed, accounts, fund);
    const exchangePreEthToken = await ethToken.instance.balanceOf.call({}, [
      exchanges[0].address,
    ]);
    const preOrderId = await exchanges[0].instance.last_offer_id.call({}, []);
    txId = await fund.instance.callOnExchange.postTransaction(
      { from: manager, gas: config.gas },
      [
        0,
        makeOrderSignature,
        ["0x0", "0x0", mlnToken.address, ethToken.address, "0x0"],
        [trade3.sellQuantity, trade3.buyQuantity, 0, 0, 0, 0],
        "0x0",
        0,
        "0x0",
        "0x0",
      ],
    );
    const gasUsed = (await api.eth.getTransactionReceipt(txId)).gasUsed;
    runningGasTotal = runningGasTotal.plus(gasUsed);
    const exchangePostEthToken = await ethToken.instance.balanceOf.call({}, [
      exchanges[0].address,
    ]);
    const post = await getAllBalances(deployed, accounts, fund);
    const postOrderId = await exchanges[0].instance.last_offer_id.call({}, []);

    t.deepEqual(preOrderId, postOrderId);
    t.deepEqual(exchangePostEthToken, exchangePreEthToken);
    t.deepEqual(
      post.manager.ether,
      pre.manager.ether.minus(runningGasTotal.times(gasPrice)),
    );
    t.deepEqual(post.fund.EthToken, pre.fund.EthToken);
  },
);

test.serial(
  "third party makes order (sell ETH-T for MLN-T) for a bad price, and MLN-T is transferred to exchange",
  async t => {
    const pre = await getAllBalances(deployed, accounts, fund);
    const exchangePreMln = await mlnToken.instance.balanceOf.call({}, [
      exchanges[0].address,
    ]);
    const exchangePreEthToken = await ethToken.instance.balanceOf.call({}, [
      exchanges[0].address,
    ]);
    txId = await ethToken.instance.approve.postTransaction(
      { from: deployer, gasPrice: config.gasPrice },
      [exchanges[0].address, trade4.sellQuantity],
    );
    let gasUsed = (await api.eth.getTransactionReceipt(txId)).gasUsed;
    runningGasTotal = runningGasTotal.plus(gasUsed);
    txId = await exchanges[0].instance.offer.postTransaction(
      { from: deployer, gas: config.gas, gasPrice: config.gasPrice },
      [
        trade4.sellQuantity,
        ethToken.address,
        trade4.buyQuantity,
        mlnToken.address,
      ],
    );
    gasUsed = (await api.eth.getTransactionReceipt(txId)).gasUsed;
    runningGasTotal = runningGasTotal.plus(gasUsed);
    const exchangePostMln = await mlnToken.instance.balanceOf.call({}, [
      exchanges[0].address,
    ]);
    const exchangePostEthToken = await ethToken.instance.balanceOf.call({}, [
      exchanges[0].address,
    ]);
    const post = await getAllBalances(deployed, accounts, fund);

    t.deepEqual(exchangePostMln, exchangePreMln);
    t.deepEqual(
      exchangePostEthToken,
      exchangePreEthToken.add(trade4.sellQuantity),
    );
    t.deepEqual(post.deployer.MlnToken, pre.deployer.MlnToken);
    t.deepEqual(
      post.deployer.EthToken,
      pre.deployer.EthToken.minus(trade4.sellQuantity),
    );
    t.deepEqual(
      post.deployer.ether,
      pre.deployer.ether.minus(runningGasTotal.times(gasPrice)),
    );
    t.deepEqual(post.investor.MlnToken, pre.investor.MlnToken);
    t.deepEqual(post.investor.EthToken, pre.investor.EthToken);
    t.deepEqual(post.investor.ether, pre.investor.ether);
    t.deepEqual(post.manager.EthToken, pre.manager.EthToken);
    t.deepEqual(post.manager.MlnToken, pre.manager.MlnToken);
    t.deepEqual(post.manager.ether, pre.manager.ether);
    t.deepEqual(post.fund.MlnToken, pre.fund.MlnToken);
    t.deepEqual(post.fund.EthToken, pre.fund.EthToken);
    t.deepEqual(post.fund.ether, pre.fund.ether);
  },
);

test.serial(
  "manager tries to take a bad order (buys ETH-T for MLN-T), RMMakeOrders should prevent it",
  async t => {
    const pre = await getAllBalances(deployed, accounts, fund);
    const exchangePreMln = Number(
      await mlnToken.instance.balanceOf.call({}, [exchanges[0].address]),
    );
    const exchangePreEthToken = Number(
      await ethToken.instance.balanceOf.call({}, [exchanges[0].address]),
    );
    const orderId = await exchanges[0].instance.last_offer_id.call({}, []);

    txId = await fund.instance.callOnExchange.postTransaction(
      { from: manager, gas: config.gas },
      [
        0,
        takeOrderSignature,
        ["0x0", "0x0", "0x0", "0x0", "0x0"],
        [0, trade4.sellQuantity, 0, 0, 0, 0],
        `0x${Number(orderId)
          .toString(16)
          .padStart(64, "0")}`,
        0,
        "0x0",
        "0x0",
      ],
    );
    const gasUsed = (await api.eth.getTransactionReceipt(txId)).gasUsed;
    runningGasTotal = runningGasTotal.plus(gasUsed);
    const exchangePostMln = Number(
      await mlnToken.instance.balanceOf.call({}, [exchanges[0].address]),
    );
    const exchangePostEthToken = Number(
      await ethToken.instance.balanceOf.call({}, [exchanges[0].address]),
    );
    const post = await getAllBalances(deployed, accounts, fund);

    t.deepEqual(exchangePostMln, exchangePreMln);
    t.deepEqual(exchangePostEthToken, exchangePreEthToken);
    t.deepEqual(post.deployer.MlnToken, pre.deployer.MlnToken);
    t.deepEqual(post.deployer.EthToken, pre.deployer.EthToken);
    t.deepEqual(post.deployer.ether, pre.deployer.ether);
    t.deepEqual(post.investor.MlnToken, pre.investor.MlnToken);
    t.deepEqual(post.investor.EthToken, pre.investor.EthToken);
    t.deepEqual(post.investor.ether, pre.investor.ether);
    t.deepEqual(post.manager.EthToken, pre.manager.EthToken);
    t.deepEqual(post.manager.MlnToken, pre.manager.MlnToken);
    t.deepEqual(
      post.manager.ether,
      pre.manager.ether.minus(runningGasTotal.times(gasPrice)),
    );
    t.deepEqual(post.fund.MlnToken, pre.fund.MlnToken);
    t.deepEqual(post.fund.EthToken, pre.fund.EthToken);
    t.deepEqual(post.fund.ether, pre.fund.ether);
  },
);

test.serial("manager makes an order and cancels it", async t => {
  txId = await fund.instance.callOnExchange.postTransaction(
    { from: manager, gas: config.gas },
    [
      0,
      makeOrderSignature,
      ["0x0", "0x0", mlnToken.address, ethToken.address, "0x0"],
      [trade1.sellQuantity, trade1.buyQuantity, 0, 0, 0, 0],
      "0x0",
      0,
      "0x0",
      "0x0",
    ],
  );
  const offerNumber = await deployed.SimpleMarket.instance.last_offer_id.call();
  let gasUsed = (await api.eth.getTransactionReceipt(txId)).gasUsed;

  const pre = await getAllBalances(deployed, accounts, fund);
  const exchangePreEthToken = Number(
    await mlnToken.instance.balanceOf.call({}, [exchanges[0].address]),
  );

  txId = await fund.instance.callOnExchange.postTransaction(
    { from: manager, gas: config.gas },
    [
      0,
      cancelOrderSignature,
      ["0x0", "0x0", mlnToken.address, "0x0", "0x0"],
      [0, 0, 0, 0, 0, 0, 0, 0],
      `0x${Number(offerNumber)
        .toString(16)
        .padStart(64, "0")}`,
      0,
      "0x0",
      "0x0",
    ],
  );

  const [orderId] = await fund.instance.getOpenOrderInfo.call({}, [
    exchanges[0].address,
    mlnToken.address,
  ]);
  const orderOpen = await exchanges[0].instance.isActive.call({}, [orderId]);
  gasUsed = (await api.eth.getTransactionReceipt(txId)).gasUsed;
  runningGasTotal = runningGasTotal.plus(gasUsed);
  const exchangePostEthToken = Number(
    await mlnToken.instance.balanceOf.call({}, [exchanges[0].address]),
  );
  const post = await getAllBalances(deployed, accounts, fund);

  t.false(orderOpen);
  t.deepEqual(exchangePostEthToken, exchangePreEthToken - trade1.sellQuantity);
  t.deepEqual(post.fund.MlnToken, pre.fund.MlnToken.add(trade1.sellQuantity));
  t.deepEqual(post.fund.EthToken, pre.fund.EthToken);
  t.deepEqual(post.fund.ether, pre.fund.ether);
  t.deepEqual(
    post.manager.ether,
    pre.manager.ether.minus(runningGasTotal.times(gasPrice)),
  );
});

// redeeming after trading
const redemptions = [
  { amount: new BigNumber(10 ** 7) },
  { amount: new BigNumber(2 * 10 ** 7) },
];
redemptions.forEach((redemption, index) => {
  test.serial(
    `Allows redemption ${index + 1} (standard redemption method)`,
    async t => {
      let investorGasTotal = new BigNumber(0);
      const investorPreShares = await fund.instance.balanceOf.call({}, [
        investor,
      ]);
      const preTotalShares = await fund.instance.totalSupply.call({}, []);
      const pre = await getAllBalances(deployed, accounts, fund);
      const mlnInCustody = await fund.instance.quantityHeldInCustodyOfExchange.call({}, [
        deployed.MlnToken.address,
      ]);
      const ethTokenInCustody = await fund.instance.quantityHeldInCustodyOfExchange.call({}, [
        deployed.EthToken.address,
      ]);
      const expectedMlnRedemption = new BigNumber(pre.fund.MlnToken).add(mlnInCustody).mul(redemption.amount).dividedToIntegerBy(preTotalShares);
      const expectedEthTokenRedemption = new BigNumber(pre.fund.EthToken).add(ethTokenInCustody).mul(redemption.amount).dividedToIntegerBy(preTotalShares);
      txId = await fund.instance.redeemAllOwnedAssets.postTransaction(
        { from: investor, gas: config.gas, gasPrice: config.gasPrice },
        [redemption.amount],
      );
      const gasUsed = (await api.eth.getTransactionReceipt(txId)).gasUsed;
      investorGasTotal = investorGasTotal.plus(gasUsed);
      const remainingApprovedEthToken = Number(
        await ethToken.instance.allowance.call({}, [investor, fund.address]),
      );
      const investorPostShares = await fund.instance.balanceOf.call({}, [
        investor,
      ]);
      const postTotalShares = await fund.instance.totalSupply.call({}, []);
      const post = await getAllBalances(deployed, accounts, fund);

      t.deepEqual(remainingApprovedEthToken, 0);
      t.deepEqual(
        postTotalShares,
        preTotalShares.minus(redemption.amount),
      );
      t.deepEqual(
        investorPostShares,
        investorPreShares.minus(redemption.amount),
      );
      t.deepEqual(post.worker.MlnToken, pre.worker.MlnToken);
      t.deepEqual(post.worker.EthToken, pre.worker.EthToken);
      t.deepEqual(post.investor.MlnToken, pre.investor.MlnToken.add(expectedMlnRedemption));
      t.deepEqual(
        post.investor.EthToken,
        pre.investor.EthToken.add(expectedEthTokenRedemption),
      );
      t.deepEqual(
        post.investor.ether,
        pre.investor.ether.minus(investorGasTotal.times(gasPrice)),
      );
      t.deepEqual(post.manager.EthToken, pre.manager.EthToken);
      t.deepEqual(post.manager.MlnToken, pre.manager.MlnToken);
      t.deepEqual(post.manager.ether, pre.manager.ether);
      t.deepEqual(post.fund.MlnToken, pre.fund.MlnToken.sub(expectedMlnRedemption));
      t.deepEqual(post.fund.EthToken, pre.fund.EthToken.sub(expectedEthTokenRedemption));
      t.deepEqual(post.fund.ether, pre.fund.ether);
    },
  );
});

test.serial(`Allows investment in native asset`, async t => {
  await fund.instance.enableInvestment.postTransaction(
    { from: manager, gas: config.gas, gasPrice: config.gasPrice },
    [[ethToken.address]],
  );
  let investorGasTotal = new BigNumber(0);
  await ethToken.instance.transfer.postTransaction(
    { from: deployer, gasPrice: config.gasPrice },
    [investor, 10 ** 14, ""],
  );
  const pre = await getAllBalances(deployed, accounts, fund);
  const investorPreShares = Number(
    await fund.instance.balanceOf.call({}, [investor]),
  );
  const sharePrice = await fund.instance.calcSharePrice.call({}, []);
  const [
    ,
    invertedNativeAssetPrice,
    nativeAssetDecimal,
  ] = await pricefeed.instance.getInvertedPriceInfo.call({}, [
    ethToken.address,
  ]);
  const wantedShareQuantity = 10 ** 10;
  const giveQuantity = Number(
    new BigNumber(wantedShareQuantity)
      .times(sharePrice)
      .dividedBy(new BigNumber(10 ** 18)) // toSmallestShareUnit
      .times(invertedNativeAssetPrice)
      .dividedBy(new BigNumber(10 ** nativeAssetDecimal))
      .times(new BigNumber(1.2)) // For price fluctuations
      .floor(),
  );
  txId = await ethToken.instance.approve.postTransaction(
    { from: investor, gasPrice: config.gasPrice, gas: config.gas },
    [fund.address, giveQuantity],
  );
  let gasUsed = (await api.eth.getTransactionReceipt(txId)).gasUsed;
  investorGasTotal = investorGasTotal.plus(gasUsed);
  await updateCanonicalPriceFeed(deployed);
  txId = await fund.instance.requestInvestment.postTransaction(
    { from: investor, gas: config.gas, gasPrice: config.gasPrice },
    [giveQuantity, wantedShareQuantity, ethToken.address],
  );
  gasUsed = (await api.eth.getTransactionReceipt(txId)).gasUsed;
  investorGasTotal = investorGasTotal.plus(gasUsed);
  await updateCanonicalPriceFeed(deployed);
  await updateCanonicalPriceFeed(deployed);
  const requestId = await fund.instance.getLastRequestId.call({}, []);
  txId = await fund.instance.executeRequest.postTransaction(
    { from: investor, gas: config.gas, gasPrice: config.gasPrice },
    [requestId],
  );
  gasUsed = (await api.eth.getTransactionReceipt(txId)).gasUsed;
  investorGasTotal = investorGasTotal.plus(gasUsed);
  const post = await getAllBalances(deployed, accounts, fund);
  const investorPostShares = Number(
    await fund.instance.balanceOf.call({}, [investor]),
  );

  t.is(Number(investorPostShares), investorPreShares + wantedShareQuantity);
  t.true(post.investor.EthToken >= pre.investor.EthToken.minus(giveQuantity));
  t.deepEqual(
    post.investor.ether,
    pre.investor.ether.minus(investorGasTotal.times(gasPrice)),
  );
  t.deepEqual(post.manager.EthToken, pre.manager.EthToken);
  t.deepEqual(post.manager.MlnToken, pre.manager.MlnToken);
  t.deepEqual(post.manager.ether, pre.manager.ether);
  t.deepEqual(post.fund.MlnToken, pre.fund.MlnToken);
  t.true(post.fund.EthToken <= pre.fund.EthToken.plus(giveQuantity));
  t.deepEqual(post.fund.ether, pre.fund.ether);
});

// Fees
test.serial("converts fees and manager receives them", async t => {
  await updateCanonicalPriceFeed(deployed);
  const pre = await getAllBalances(deployed, accounts, fund);
  const preManagerShares = await fund.instance.balanceOf.call({}, [manager]);
  const totalSupply = await fund.instance.totalSupply.call({}, []);
  txId = await fund.instance.calcSharePrice.postTransaction(
    { from: manager, gas: config.gas, gasPrice: config.gasPrice },
    [],
  );
  const [gav, , , unclaimedFees, ,] = Object.values(
    await fund.instance.atLastUnclaimedFeeAllocation.call({}, []),
  );
  const shareQuantity = Math.floor(
    Number(totalSupply.mul(unclaimedFees).div(gav)),
  );
  const gasUsed = (await api.eth.getTransactionReceipt(txId)).gasUsed;
  runningGasTotal = runningGasTotal.plus(gasUsed);
  const postManagerShares = await fund.instance.balanceOf.call({}, [manager]);
  const post = await getAllBalances(deployed, accounts, fund);

  t.deepEqual(postManagerShares, preManagerShares.add(shareQuantity));
  t.deepEqual(post.investor.MlnToken, pre.investor.MlnToken);
  t.deepEqual(post.investor.EthToken, pre.investor.EthToken);
  t.deepEqual(post.investor.ether, pre.investor.ether);
  t.deepEqual(post.manager.EthToken, pre.manager.EthToken);
  t.deepEqual(post.manager.MlnToken, pre.manager.MlnToken);
  t.deepEqual(
    post.manager.ether,
    pre.manager.ether.minus(runningGasTotal.times(gasPrice)),
  );
  t.deepEqual(post.fund.MlnToken, pre.fund.MlnToken);
  t.deepEqual(post.fund.EthToken, pre.fund.EthToken);
  t.deepEqual(post.fund.ether, pre.fund.ether);
});

test.serial("manger opens new order, but not anyone can cancel", async t => {
  const pre = await getAllBalances(deployed, accounts, fund);
  txId = await fund.instance.callOnExchange.postTransaction(
    { from: manager, gas: config.gas },
    [
      0,
      makeOrderSignature,
      ["0x0", "0x0", mlnToken.address, ethToken.address, "0x0"],
      [trade1.sellQuantity, trade1.buyQuantity, 0, 0, 0, 0, 0, 0],
      "0x0",
      0,
      "0x0",
      "0x0",
    ],
  );
  const gasUsed = (await api.eth.getTransactionReceipt(txId)).gasUsed;
  runningGasTotal = runningGasTotal.plus(gasUsed);
  const offerNumber = await exchanges[0].instance.last_offer_id.call({}, []);
  txId = await fund.instance.callOnExchange.postTransaction(
    { from: accounts[3], gas: config.gas },
    [
      0,
      cancelOrderSignature,
      ["0x0", "0x0", mlnToken.address, "0x0", "0x0"],
      [0, 0, 0, 0, 0, 0, 0, 0],
      `0x${Number(offerNumber)
        .toString(16)
        .padStart(64, "0")}`,
      0,
      "0x0",
      "0x0",
    ],
  );
  const gasUsedCancel = (await api.eth.getTransactionReceipt(txId)).gasUsed;
  const offerActive = await exchanges[0].instance.isActive.call({}, [
    offerNumber,
  ]);
  const post = await getAllBalances(deployed, accounts, fund);

  t.is(Number(gasUsedCancel), config.gas);
  t.true(offerActive);
  t.deepEqual(post.investor.MlnToken, pre.investor.MlnToken);
  t.deepEqual(post.investor.EthToken, pre.investor.EthToken);
  t.deepEqual(post.investor.ether, pre.investor.ether);
  t.deepEqual(post.manager.EthToken, pre.manager.EthToken);
  t.deepEqual(post.manager.MlnToken, pre.manager.MlnToken);
  t.deepEqual(
    post.manager.ether,
    pre.manager.ether.minus(runningGasTotal.times(gasPrice)),
  );
  t.deepEqual(post.fund.MlnToken, pre.fund.MlnToken.minus(trade1.sellQuantity));
  t.deepEqual(post.fund.EthToken, pre.fund.EthToken);
  t.deepEqual(post.fund.ether, pre.fund.ether);
});

// shutdown fund
test.serial("manager can shut down a fund", async t => {
  const pre = await getAllBalances(deployed, accounts, fund);
  txId = await version.instance.shutDownFund.postTransaction(
    { from: manager, gasPrice: config.gasPrice },
    [fund.address],
  );
  const gasUsed = (await api.eth.getTransactionReceipt(txId)).gasUsed;
  runningGasTotal = runningGasTotal.plus(gasUsed);
  const isShutDown = await fund.instance.isShutDown.call({}, []);
  const post = await getAllBalances(deployed, accounts, fund);

  t.true(isShutDown);
  t.deepEqual(post.investor.MlnToken, pre.investor.MlnToken);
  t.deepEqual(post.investor.EthToken, pre.investor.EthToken);
  t.deepEqual(post.investor.ether, pre.investor.ether);
  t.deepEqual(post.manager.EthToken, pre.manager.EthToken);
  t.deepEqual(post.manager.MlnToken, pre.manager.MlnToken);
  t.deepEqual(
    post.manager.ether,
    pre.manager.ether.minus(runningGasTotal.times(gasPrice)),
  );
  t.deepEqual(post.fund.MlnToken, pre.fund.MlnToken);
  t.deepEqual(post.fund.EthToken, pre.fund.EthToken);
  t.deepEqual(post.fund.ether, pre.fund.ether);
});

test.serial("shutdown of fund allows anyone to cancel order", async t => {
  const offerNumber = await exchanges[0].instance.last_offer_id.call({}, []);
  txId = await fund.instance.callOnExchange.postTransaction(
    { from: accounts[3], gas: config.gas },
    [
      0,
      cancelOrderSignature,
      ["0x0", "0x0", mlnToken.address, "0x0", "0x0"],
      [0, 0, 0, 0, 0, 0, 0, 0],
      `0x${Number(offerNumber)
        .toString(16)
        .padStart(64, "0")}`,
      0,
      "0x0",
      "0x0",
    ],
  );
  const offerActive = await exchanges[0].instance.isActive.call({}, [
    offerNumber,
  ]);

  t.false(offerActive);
});
